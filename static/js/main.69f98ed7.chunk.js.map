{"version":3,"sources":["components/button.js","components/board.js","logic/constants.js","logic/game.js","logic/minimax.js","App.js","serviceWorker.js","index.js"],"names":["Button","value","onClick","className","type","e","target","blur","Board","ROWS","COLS","rows","r","cols","c","col","key","id","push","row","MODEL_URL","Connect4Game","checkWin","turn","win","i","leftBound","rightBound","topBound","bottomBound","checkWinHelper","newRightBound","incrementRow","incrementCol","invertRow","invertCol","offset","board","document","getElementById","classList","add","this","reset","Array","fill","map","action","dropRow","getDropRow","oldTurn","checkDraw","getState","winner","boardCopy","getValidActions","validActions","getStateTensor","state","isArray","tf","reshape","minimax","depth","alpha","beta","maximizingPlayer","player","countWindows","isGameOver","weightedSum","CONSECUTIVE_TO_WIN","getOtherPlayer","getHeuristic","maxVal","Number","NEGATIVE_INFINITY","val","getNextBoard","Math","max","minVal","POSITIVE_INFINITY","min","targetCount","count","playerCount","emptyCount","nextBoard","OPTIONS","App","props","handleOnChangePlayer","newPlayer","selectedIndex","setState","p1Mode","p2Mode","runAI","handleOnChangeAISpeed","aiSpeed","handleOnClickNewGame","game","button","remove","handleOnClickBoard","includes","step","getPlayerNumber","clearTimeout","timer","setTimeout","randomAI","minimaxAI","qLearningAI","loadModel","model","floor","random","length","maxCols","stateTensor","getInvertedState","qs","from","predict","dataSync","qActions","forEach","q","maxQ","Infinity","qAction","turnOrWinnerText","onChange","option","defaultValue","href","bannerColor","octoColor","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.69f98ed7.chunk.js","sourcesContent":["import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nconst Button = ({ value, onClick }) => {\r\n  const handleOnClick = (e) => {\r\n    // Remove focus from button\r\n    e.target.blur();\r\n    onClick();\r\n  };\r\n\r\n  return (\r\n    <button\r\n      className=\"btn btn-primary btn-lg\"\r\n      type=\"button\"\r\n      onClick={handleOnClick}\r\n    >\r\n      {value}\r\n    </button>\r\n  );\r\n};\r\n\r\nButton.propTypes = {\r\n  value: PropTypes.string,\r\n  onClick: PropTypes.func,\r\n};\r\n\r\nexport default Button;\r\n","import React from \"react\";\r\n\r\nconst Board = ({ ROWS, COLS, onClick }) => {\r\n  const rows = [];\r\n\r\n  for (let r = 0; r < ROWS; r++) {\r\n    const cols = [];\r\n\r\n    for (let c = 0; c < COLS; c++) {\r\n      const col = (\r\n        <td key={`${r}-${c}`}>\r\n          <button\r\n            type=\"button\"\r\n            className=\"board-button\"\r\n            id={`button-${r}-${c}`}\r\n            onClick={() => onClick(c)}\r\n          ></button>\r\n        </td>\r\n      );\r\n\r\n      cols.push(col);\r\n    }\r\n\r\n    const row = <tr key={r}>{cols}</tr>;\r\n    rows.push(row);\r\n  }\r\n\r\n  return (\r\n    <div className=\"table-responsive\">\r\n      <table className=\"table\">\r\n        <tbody>{rows}</tbody>\r\n      </table>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","// Game settings\r\nexport const CONSECUTIVE_TO_WIN = 4;\r\nexport const ROWS = 6;\r\nexport const COLS = 7;\r\n\r\n// Game representation\r\nexport const GAME_IN_PROGRESS = 2;\r\nexport const PLAYER_1 = 1;\r\nexport const DRAW = 0;\r\nexport const PLAYER_2 = -1;\r\n\r\n// Flag indicating whether to train or run the main app\r\nexport const TRAIN_Q_LEARNING = false;\r\n\r\n// Flag indicating whether to resume training or start fresh\r\nexport const RESUME_TRAINING = true;\r\n\r\n// Model url\r\nexport const MODEL_URL =\r\n  \"https://connect4-ai.storage.googleapis.com/connect4model.json\";\r\n\r\n// Rewards\r\nexport const LOSS_REWARD = -1;\r\nexport const DRAW_REWARD = 0;\r\nexport const WIN_REWARD = 1;\r\nexport const STEP_REWARD = 0;\r\n\r\n// Q-learning hyperparameters\r\nexport const NUM_EPISODES = 1e3;\r\nexport const REPLAY_BUFFER_SIZE = 1e4;\r\nexport const BATCH_SIZE = 16;\r\nexport const GAMMA = 0.99;\r\nexport const LEARNING_RATE = 1e-3;\r\nexport const SYNC_EVERY_FRAMES = 1e3;\r\n\r\n// Epsilon-greedy algorithm\r\nexport const EPSILON_INIT = 0.7;\r\nexport const EPSILON_FINAL = 0.01;\r\nexport const EPSILON_DECAY_FRAMES = 1e5;\r\nexport const EPSILON_INCREMENT =\r\n  (EPSILON_FINAL - EPSILON_INIT) / EPSILON_DECAY_FRAMES;\r\n","import * as tf from \"@tensorflow/tfjs\";\r\nimport {\r\n  CONSECUTIVE_TO_WIN,\r\n  ROWS,\r\n  COLS,\r\n  GAME_IN_PROGRESS,\r\n  PLAYER_1,\r\n  DRAW,\r\n  PLAYER_2,\r\n  TRAIN_Q_LEARNING,\r\n  LOSS_REWARD,\r\n  DRAW_REWARD,\r\n  WIN_REWARD,\r\n  STEP_REWARD,\r\n} from \"./constants\";\r\n\r\nexport class Connect4Game {\r\n  /**\r\n   * Resets the game on creation.\r\n   */\r\n  constructor() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Resets the game, which is the board and the turn.\r\n   * @return {number} (if TRAIN_Q_LEARNING) the player that goes first\r\n   */\r\n  reset() {\r\n    this.board = new Array(ROWS).fill(0).map(() => new Array(COLS).fill(0));\r\n\r\n    if (TRAIN_Q_LEARNING) {\r\n      this.turn = Math.random() < 0.5 ? PLAYER_1 : PLAYER_2;\r\n\r\n      // Return the player that went first\r\n      return this.turn;\r\n    }\r\n\r\n    // If not training, PLAYER_1 always starts\r\n    this.turn = PLAYER_1;\r\n  }\r\n\r\n  /**\r\n   * Steps the game with the given action (column).\r\n   * @param {number} action The action to step the game with\r\n   * @return {Object} (if TRAIN_Q_LEARNING) the reward, next state, and done flag; otherwise the new board, turn, winner, and drop row\r\n   */\r\n  step(action) {\r\n    // Action is the chosen column\r\n    let dropRow = this.getDropRow(action);\r\n\r\n    // Update board\r\n    this.board[dropRow][action] = this.turn;\r\n\r\n    // Save old turn to check for win\r\n    const oldTurn = this.turn;\r\n\r\n    // Update turn\r\n    this.turn = this.turn === PLAYER_1 ? PLAYER_2 : PLAYER_1;\r\n\r\n    if (this.checkDraw()) {\r\n      if (TRAIN_Q_LEARNING) {\r\n        // Draw does not care who caused the draw\r\n        return { reward: DRAW_REWARD, nextState: this.getState(), done: true };\r\n      }\r\n\r\n      return { board: this.getState(), turn: this.turn, winner: DRAW, dropRow };\r\n    }\r\n\r\n    if (this.checkWin(dropRow, action, oldTurn)) {\r\n      if (TRAIN_Q_LEARNING) {\r\n        // Reward is relative to PLAYER_1, not the player that went first\r\n        const reward = oldTurn === PLAYER_1 ? WIN_REWARD : LOSS_REWARD;\r\n\r\n        return { reward, nextState: this.getState(), done: true };\r\n      }\r\n\r\n      return {\r\n        board: this.getState(),\r\n        turn: this.turn,\r\n        winner: oldTurn,\r\n        dropRow,\r\n      };\r\n    }\r\n\r\n    if (TRAIN_Q_LEARNING) {\r\n      // Game not over\r\n      return { reward: STEP_REWARD, nextState: this.getState(), done: false };\r\n    }\r\n\r\n    return {\r\n      board: this.getState(),\r\n      turn: this.turn,\r\n      winner: GAME_IN_PROGRESS,\r\n      dropRow,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns a copy of the board.\r\n   * @return {Array} a copy of the board.\r\n   */\r\n  getState() {\r\n    // Deep copy the board\r\n    const boardCopy = [];\r\n\r\n    for (const row of this.board) {\r\n      boardCopy.push([...row]);\r\n    }\r\n\r\n    return boardCopy;\r\n  }\r\n\r\n  /**\r\n   * Returns a copy of the board with inverted player values.\r\n   * @return {Array} a copy of the board with inverted player values\r\n   */\r\n  getInvertedState() {\r\n    const boardCopy = this.getState();\r\n\r\n    // Invert player discs, leave empty slots alone\r\n    for (let r = 0; r < ROWS; r++) {\r\n      for (let c = 0; c < COLS; c++) {\r\n        if (boardCopy[r][c] === PLAYER_1) {\r\n          boardCopy[r][c] = PLAYER_2;\r\n        } else if (boardCopy[r][c] === PLAYER_2) {\r\n          boardCopy[r][c] = PLAYER_1;\r\n        }\r\n      }\r\n    }\r\n\r\n    return boardCopy;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the game is a draw.\r\n   * @return {boolean} whether the game is a draw\r\n   */\r\n  checkDraw() {\r\n    return checkDraw(this.board);\r\n  }\r\n\r\n  /**\r\n   * Returns whether the game is won by the turn player's piece at the row and column.\r\n   * @param {number} row The row to check\r\n   * @param {number} col The column to check\r\n   * @param {number} turn The player to check\r\n   * @return {boolean} whether the game is won by the turn player's piece at the row and column\r\n   */\r\n  checkWin = (row, col, turn) => {\r\n    /*\r\n     * Only if !TRAIN_Q_LEARNING.\r\n     * win = checkWinHelper() || win must be in that order,\r\n     * otherwise checkWinHelper() will not be called on all sliding windows,\r\n     * and not all wins will be shown by the button styles.\r\n     */\r\n    let win = false;\r\n\r\n    // Pivot on the placed disc\r\n    for (let i = 0; i < CONSECUTIVE_TO_WIN; i++) {\r\n      const leftBound = col - i;\r\n      const rightBound = col + CONSECUTIVE_TO_WIN - i - 1;\r\n      const topBound = row - i;\r\n      const bottomBound = row + CONSECUTIVE_TO_WIN - i - 1;\r\n\r\n      // Horizontal, right to left\r\n      if (leftBound >= 0 && rightBound < COLS) {\r\n        win =\r\n          this.checkWinHelper(\r\n            row,\r\n            leftBound,\r\n            false,\r\n            true,\r\n            false,\r\n            false,\r\n            turn\r\n          ) || win;\r\n\r\n        if (win && TRAIN_Q_LEARNING) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Vertical, bottom to top\r\n      if (topBound >= 0 && bottomBound < ROWS) {\r\n        win =\r\n          this.checkWinHelper(topBound, col, true, false, false, false, turn) ||\r\n          win;\r\n\r\n        if (win && TRAIN_Q_LEARNING) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Negative Diagonal, bottom right to top left\r\n      if (\r\n        leftBound >= 0 &&\r\n        rightBound < COLS &&\r\n        topBound >= 0 &&\r\n        bottomBound < ROWS\r\n      ) {\r\n        win =\r\n          this.checkWinHelper(\r\n            topBound,\r\n            leftBound,\r\n            true,\r\n            true,\r\n            false,\r\n            false,\r\n            turn\r\n          ) || win;\r\n\r\n        if (win && TRAIN_Q_LEARNING) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Positive Diagonal, bottom left to top right\r\n      const newLeftBound = col - CONSECUTIVE_TO_WIN + i + 1;\r\n      const newRightBound = col + i;\r\n      if (\r\n        newLeftBound >= 0 &&\r\n        newRightBound < COLS &&\r\n        topBound >= 0 &&\r\n        bottomBound < ROWS\r\n      ) {\r\n        win =\r\n          this.checkWinHelper(\r\n            topBound,\r\n            newRightBound,\r\n            true,\r\n            true,\r\n            false,\r\n            true,\r\n            turn\r\n          ) || win;\r\n\r\n        if (win && TRAIN_Q_LEARNING) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return win;\r\n  };\r\n\r\n  /**\r\n   * Returns whether this portion of the board contains a win by the current turn player.\r\n   * @param {number} row The row to check\r\n   * @param {number} col The column to check\r\n   * @param {boolean} incrementRow Whether to increment the row\r\n   * @param {boolean} incrementCol Whether to increment the column\r\n   * @param {boolean} invertRow Whether to invert the increment direction for row\r\n   * @param {boolean} invertCol Whether to invert the increment direction for column\r\n   * @param {number} turn The current player\r\n   * @return {boolean} Whether this portion of the board contains a win by the current turn player\r\n   */\r\n  checkWinHelper = (\r\n    row,\r\n    col,\r\n    incrementRow,\r\n    incrementCol,\r\n    invertRow,\r\n    invertCol,\r\n    turn\r\n  ) => {\r\n    // Check if all discs by current turn player\r\n    for (let offset = 0; offset < CONSECUTIVE_TO_WIN; offset++) {\r\n      const r = row + (incrementRow ? (invertRow ? -offset : offset) : 0);\r\n      const c = col + (incrementCol ? (invertCol ? -offset : offset) : 0);\r\n\r\n      if (this.board[r][c] !== turn) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Add win class to style button\r\n    for (let offset = 0; offset < CONSECUTIVE_TO_WIN; offset++) {\r\n      const r = row + (incrementRow ? (invertRow ? -offset : offset) : 0);\r\n      const c = col + (incrementCol ? (invertCol ? -offset : offset) : 0);\r\n      const button = document.getElementById(`button-${r}-${c}`);\r\n\r\n      button.classList.add(\"win\");\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Returns an array of valid actions for this state.\r\n   * @return {Array} an array of valid actions for this state\r\n   */\r\n  getValidActions() {\r\n    return getValidActions(this.board);\r\n  }\r\n\r\n  /**\r\n   * Returns the lowest row for the given action (column).\r\n   * @param {number} action The action (column) to take\r\n   * @return {number} the lowest row for the given action (column)\r\n   */\r\n  getDropRow(action) {\r\n    return getDropRow(this.board, action);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns whether the board is a draw.\r\n * @param {Array} board The game board as a 2D array\r\n * @return {boolean} whether the board is a draw\r\n */\r\nexport function checkDraw(board) {\r\n  // Check if any top row is empty\r\n  for (let col = 0; col < COLS; col++) {\r\n    if (board[0][col] === 0) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // All top row is full\r\n  return true;\r\n}\r\n\r\n/**\r\n * Returns an array of valid actions for the board.\r\n * @param {Array} board The game board as a 2D array\r\n * @return {Array} an array of valid actions for the board\r\n */\r\nexport function getValidActions(board) {\r\n  const validActions = [];\r\n\r\n  // Valid action is column with empty top row\r\n  for (let col = 0; col < COLS; col++) {\r\n    if (board[0][col] === 0) {\r\n      validActions.push(col);\r\n    }\r\n  }\r\n\r\n  return validActions;\r\n}\r\n\r\n/**\r\n * Returns the lowest row for the given action (column).\r\n * @param {Array} board The game board as a 2D array\r\n * @param {number} action The action (column) taken\r\n * @return {number} the lowest row for the given action (column)\r\n */\r\nexport function getDropRow(board, action) {\r\n  for (let row = ROWS - 1; row >= 0; row--) {\r\n    if (board[row][action] === 0) {\r\n      return row;\r\n    }\r\n  }\r\n\r\n  // Invalid action, column is full\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Returns a TensorFlowJS Tensor of shape [batch size, rows, cols, 1 channel].\r\n * @param {Array} state One or many game states, which are each 2D arrays\r\n * @return {Object} a TensorFlowJS Tensor of shape [batch size, rows, cols, 1 channel]\r\n */\r\nexport function getStateTensor(state) {\r\n  // Convert to array if not already\r\n  if (!Array.isArray(state)) {\r\n    state = [state];\r\n  }\r\n\r\n  // Shape: [batch size, rows, cols, 1 channel]\r\n  return tf.tensor(state).reshape([-1, ROWS, COLS, 1]);\r\n}\r\n","import {\r\n  CONSECUTIVE_TO_WIN,\r\n  ROWS,\r\n  COLS,\r\n  PLAYER_1,\r\n  PLAYER_2,\r\n} from \"./constants\";\r\nimport { checkDraw, getValidActions, getDropRow } from \"./game\";\r\n\r\n/**\r\n * Minimax algorithm with alpha-beta pruning.\r\n * @param {Array} board The game board as a 2D array\r\n * @param {number} depth The minimax depth\r\n * @param {number} alpha Alpha for alpha-beta pruning\r\n * @param {number} beta Beta for alpha-beta pruning\r\n * @param {boolean} maximizingPlayer Whether this call is for the maximizing player\r\n * @param {number} player The starting (maximizing) player\r\n * @return {number} The minimax value\r\n */\r\nexport function minimax(board, depth, alpha, beta, maximizingPlayer, player) {\r\n  // Reached desired depth or game over, return heuristic\r\n  if (depth === 0 || isGameOver(board)) {\r\n    return getHeuristic(board, player);\r\n  }\r\n\r\n  // Maximizing player\r\n  if (maximizingPlayer) {\r\n    let maxVal = Number.NEGATIVE_INFINITY;\r\n\r\n    for (const col of getValidActions(board)) {\r\n      const nextBoard = getNextBoard(board, col, player);\r\n      const val = minimax(nextBoard, depth - 1, alpha, beta, false, player);\r\n\r\n      maxVal = Math.max(maxVal, val);\r\n      alpha = Math.max(alpha, val);\r\n\r\n      if (alpha >= beta) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return maxVal;\r\n  }\r\n\r\n  // Minimizing player\r\n  let minVal = Number.POSITIVE_INFINITY;\r\n\r\n  for (const col of getValidActions(board)) {\r\n    const nextBoard = getNextBoard(board, col, getOtherPlayer());\r\n    const val = minimax(nextBoard, depth - 1, alpha, beta, true, player);\r\n\r\n    minVal = Math.min(minVal, val);\r\n    beta = Math.min(beta, val);\r\n\r\n    if (beta <= alpha) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return minVal;\r\n}\r\n\r\n/**\r\n * Returns whether the game is over.\r\n * @param {Array} board The game board as a 2D array\r\n * @return {boolean} Whether the game is over\r\n */\r\nfunction isGameOver(board) {\r\n  return (\r\n    countWindows(board, PLAYER_1, CONSECUTIVE_TO_WIN) > 0 ||\r\n    countWindows(board, PLAYER_2, CONSECUTIVE_TO_WIN) > 0 ||\r\n    checkDraw(board)\r\n  );\r\n}\r\n\r\n/**\r\n * Returns the number of valid windows containing a target number of discs for a player.\r\n * @param {Array} board The game board as a 2D array\r\n * @param {number} player The player to count windows for\r\n * @param {number} targetCount The number of discs needed to count a window\r\n * @return {number} The number of valid windows containing a target number of discs for a player\r\n */\r\nfunction countWindows(board, player, targetCount) {\r\n  let count = 0;\r\n\r\n  // Horizontal\r\n  for (let row = 0; row < ROWS; row++) {\r\n    for (let col = 0; col < COLS - CONSECUTIVE_TO_WIN + 1; col++) {\r\n      let playerCount = 0;\r\n      let emptyCount = 0;\r\n\r\n      // Count number of player discs and empty spots\r\n      for (let i = 0; i < CONSECUTIVE_TO_WIN; i++) {\r\n        const val = board[row][col + i];\r\n\r\n        if (val === player) {\r\n          playerCount++;\r\n        } else if (val === 0) {\r\n          emptyCount++;\r\n        }\r\n      }\r\n\r\n      // Check if this window counts\r\n      if (\r\n        playerCount === targetCount &&\r\n        emptyCount === CONSECUTIVE_TO_WIN - playerCount\r\n      ) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Vertical\r\n  for (let row = 0; row < ROWS - CONSECUTIVE_TO_WIN + 1; row++) {\r\n    for (let col = 0; col < COLS; col++) {\r\n      let playerCount = 0;\r\n      let emptyCount = 0;\r\n\r\n      // Count number of player discs and empty spots\r\n      for (let i = 0; i < CONSECUTIVE_TO_WIN; i++) {\r\n        const val = board[row + i][col];\r\n\r\n        if (val === player) {\r\n          playerCount++;\r\n        } else if (val === 0) {\r\n          emptyCount++;\r\n        }\r\n      }\r\n\r\n      // Check if this window counts\r\n      if (\r\n        playerCount === targetCount &&\r\n        emptyCount === CONSECUTIVE_TO_WIN - playerCount\r\n      ) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Negative Diagonal\r\n  for (let row = 0; row < ROWS - CONSECUTIVE_TO_WIN + 1; row++) {\r\n    for (let col = 0; col < COLS - CONSECUTIVE_TO_WIN + 1; col++) {\r\n      let playerCount = 0;\r\n      let emptyCount = 0;\r\n\r\n      // Count number of player discs and empty spots\r\n      for (let i = 0; i < CONSECUTIVE_TO_WIN; i++) {\r\n        const val = board[row + i][col + i];\r\n\r\n        if (val === player) {\r\n          playerCount++;\r\n        } else if (val === 0) {\r\n          emptyCount++;\r\n        }\r\n      }\r\n\r\n      // Check if this window counts\r\n      if (\r\n        playerCount === targetCount &&\r\n        emptyCount === CONSECUTIVE_TO_WIN - playerCount\r\n      ) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Positive Diagonal\r\n  for (let row = 0; row < ROWS - CONSECUTIVE_TO_WIN + 1; row++) {\r\n    for (let col = COLS - 1; col > CONSECUTIVE_TO_WIN - 2; col--) {\r\n      let playerCount = 0;\r\n      let emptyCount = 0;\r\n\r\n      // Count number of player discs and empty spots\r\n      for (let i = 0; i < CONSECUTIVE_TO_WIN; i++) {\r\n        const val = board[row + i][col - i];\r\n\r\n        if (val === player) {\r\n          playerCount++;\r\n        } else if (val === 0) {\r\n          emptyCount++;\r\n        }\r\n      }\r\n\r\n      // Check if this window counts\r\n      if (\r\n        playerCount === targetCount &&\r\n        emptyCount === CONSECUTIVE_TO_WIN - playerCount\r\n      ) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Returns the heuristic for the game board for the given player.\r\n * @param {Array} board The game board as a 2D array\r\n * @param {number} player The player to get the heuristic for\r\n * @return {number} the heuristic for the game board for the given player\r\n */\r\nfunction getHeuristic(board, player) {\r\n  let weightedSum = 0;\r\n\r\n  // Weights increase alternatingly\r\n  /*\r\n        p1_4: 1e5\r\n        p1_3: 1e3\r\n        p1_2: 1e1\r\n        p2_2: -1e0\r\n        p2_3: -1e2\r\n        p2_4: -1e4\r\n     */\r\n  for (let i = 0; i < CONSECUTIVE_TO_WIN - 1; i++) {\r\n    // Positive\r\n    weightedSum += 10 ** (2 * i + 1) * countWindows(board, player, i + 2);\r\n\r\n    // Negative\r\n    weightedSum -=\r\n      10 ** (2 * i) * countWindows(board, getOtherPlayer(player), i + 2);\r\n  }\r\n\r\n  return weightedSum;\r\n}\r\n\r\n/**\r\n * Returns the other player to the given player.\r\n * @param {number} player The player\r\n * @return {number} the other player to the given player\r\n */\r\nfunction getOtherPlayer(player) {\r\n  return player === PLAYER_1 ? PLAYER_2 : PLAYER_1;\r\n}\r\n\r\n/**\r\n * Returns a new game board after dropping the disc in the given column.\r\n * @param {Array} board The game board as a 2D array\r\n * @param {number} col The column to drop the disc\r\n * @param {number} player The player\r\n * @return {Array} a new game board after dropping the disc in the given column\r\n */\r\nexport function getNextBoard(board, col, player) {\r\n  // Deep copy the board\r\n  const nextBoard = [];\r\n\r\n  for (const row of board) {\r\n    nextBoard.push([...row]);\r\n  }\r\n\r\n  // Set the disc\r\n  const row = getDropRow(nextBoard, col);\r\n  nextBoard[row][col] = player;\r\n\r\n  return nextBoard;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Button from \"./components/button\";\r\nimport GithubCorner from \"react-github-corner\";\r\nimport Board from \"./components/board\";\r\nimport { train } from \"./logic/train\";\r\nimport { Connect4Game, getStateTensor } from \"./logic/game\";\r\nimport {\r\n  ROWS,\r\n  COLS,\r\n  GAME_IN_PROGRESS,\r\n  PLAYER_1,\r\n  DRAW,\r\n  PLAYER_2,\r\n  TRAIN_Q_LEARNING,\r\n  MODEL_URL,\r\n} from \"./logic/constants\";\r\nimport { minimax, getNextBoard } from \"./logic/minimax\";\r\nimport * as tf from \"@tensorflow/tfjs\";\r\n\r\nconst OPTIONS = [\r\n  \"Player\",\r\n  \"Rookie (random)\",\r\n  \"Easy (1-step minimax)\",\r\n  \"Normal (deep Q-learning)\",\r\n  \"Hard (2-step minimax)\",\r\n  \"Expert (4-step minimax)\",\r\n  \"Extreme (6-step minimax)\",\r\n];\r\nconst MAX_AI_SPEED_SECONDS = 0.01;\r\nconst MINIMAX_DEPTH_1 = 1;\r\nconst MINIMAX_DEPTH_2 = 2;\r\nconst MINIMAX_DEPTH_4 = 4;\r\nconst MINIMAX_DEPTH_6 = 6;\r\n\r\nconst MODE_PLAYER = 0;\r\nconst MODE_ROOKIE = 1;\r\nconst MODE_EASY = 2;\r\nconst MODE_NORMAL = 3;\r\nconst MODE_HARD = 4;\r\nconst MODE_EXPERT = 5;\r\nconst MODE_EXTREME = 6;\r\n\r\nconst SIMULATE = false;\r\nconst P1_MODE = MODE_NORMAL;\r\nconst P2_MODE = MODE_EASY;\r\nconst NUM_SIMULATE = 100;\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // Instantiate game instance\r\n    this.game = new Connect4Game();\r\n\r\n    this.state = {\r\n      board: this.game.getState(),\r\n      turn: PLAYER_1,\r\n      winner: GAME_IN_PROGRESS,\r\n      p1Mode: MODE_PLAYER,\r\n      p2Mode: MODE_PLAYER,\r\n      aiSpeed: 0.02,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    if (TRAIN_Q_LEARNING) {\r\n      train();\r\n    } else {\r\n      this.loadModel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loads the Q-learning model.\r\n   */\r\n  async loadModel() {\r\n    this.model = await tf.loadLayersModel(MODEL_URL);\r\n\r\n    if (SIMULATE) {\r\n      this.numSimulate = NUM_SIMULATE;\r\n      this.p1Wins = 0;\r\n      this.p2Wins = 0;\r\n      this.draws = 0;\r\n      this.setState({ p1Mode: P1_MODE, p2Mode: P2_MODE }, this.runAI);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Changes the player mode.\r\n   * @param {Object} e The event containing the new player\r\n   * @param {number} player The player to change\r\n   */\r\n  handleOnChangePlayer = (e, player) => {\r\n    const newPlayer = e.target.selectedIndex;\r\n\r\n    this.setState(\r\n      player === PLAYER_1 ? { p1Mode: newPlayer } : { p2Mode: newPlayer },\r\n      this.runAI\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Changes the AI speed.\r\n   * @param {Object} e The event containing the new AI speed\r\n   */\r\n  handleOnChangeAISpeed = (e) => {\r\n    const aiSpeed = Number(e.target.value);\r\n\r\n    this.setState({ aiSpeed }, this.runAI);\r\n  };\r\n\r\n  /**\r\n   * Starts a new game.\r\n   */\r\n  handleOnClickNewGame = () => {\r\n    this.game.reset();\r\n\r\n    this.setState(\r\n      {\r\n        board: this.game.getState(),\r\n        turn: PLAYER_1,\r\n        winner: GAME_IN_PROGRESS,\r\n      },\r\n      this.runAI\r\n    );\r\n\r\n    // Reset board button styles\r\n    for (let row = 0; row < ROWS; row++) {\r\n      for (let col = 0; col < COLS; col++) {\r\n        const button = document.getElementById(`button-${row}-${col}`);\r\n\r\n        button.classList.remove(\"p1\");\r\n        button.classList.remove(\"p2\");\r\n        button.classList.remove(\"win\");\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles user clicks on the board.\r\n   * @param {number} action The action (column) clicked by the user\r\n   */\r\n  handleOnClickBoard = (action) => {\r\n    // Don't allow if game over\r\n    if (this.state.winner !== GAME_IN_PROGRESS) {\r\n      return;\r\n    }\r\n\r\n    // Don't allow if AI's turn\r\n    if (\r\n      (this.state.turn === PLAYER_1 && this.state.p1Mode !== MODE_PLAYER) ||\r\n      (this.state.turn === PLAYER_2 && this.state.p2Mode !== MODE_PLAYER)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const validActions = this.game.getValidActions();\r\n\r\n    // Don't allow if not valid action\r\n    if (!validActions.includes(action)) {\r\n      return;\r\n    }\r\n\r\n    this.step(action);\r\n  };\r\n\r\n  /**\r\n   * Steps the game with the given action.\r\n   * @param {number} action The action (column) to step the game with.\r\n   */\r\n  step = (action) => {\r\n    // Take step, get new board, turn, winner, and drop row\r\n    const { board, turn, winner, dropRow } = this.game.step(action);\r\n\r\n    // Update button style\r\n    const button = document.getElementById(`button-${dropRow}-${action}`);\r\n\r\n    // this.state.turn has not changed yet\r\n    button.classList.add(`p${this.getPlayerNumber()}`);\r\n\r\n    // Update state\r\n    this.setState({ board, turn, winner }, this.runAI);\r\n  };\r\n\r\n  /**\r\n   * Returns the string representing the current turn player.\r\n   * @return {string} the string representing the current turn player\r\n   */\r\n  getPlayerNumber() {\r\n    return this.state.turn === PLAYER_1 ? \"1\" : \"2\";\r\n  }\r\n\r\n  /**\r\n   * Runs the AI at the set AI speed.\r\n   */\r\n  runAI = () => {\r\n    clearTimeout(this.timer);\r\n\r\n    // Only run AI if not game over\r\n    if (this.state.winner !== GAME_IN_PROGRESS) {\r\n      if (SIMULATE) {\r\n        if (this.state.winner === PLAYER_1) {\r\n          this.p1Wins++;\r\n        } else if (this.state.winner === PLAYER_2) {\r\n          this.p2Wins++;\r\n        } else {\r\n          this.draws++;\r\n        }\r\n\r\n        this.numSimulate--;\r\n\r\n        if (this.numSimulate === 0) {\r\n          console.log(\r\n            `P1: ${this.p1Wins} | P2: ${this.p2Wins} | Draws: ${this.draws}`\r\n          );\r\n        } else {\r\n          this.handleOnClickNewGame();\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // Game not over\r\n    this.timer = setTimeout(\r\n      () => {\r\n        if (this.state.turn === PLAYER_1 && this.state.p1Mode !== MODE_PLAYER) {\r\n          // Run AI for player 1\r\n          if (this.state.p1Mode === MODE_ROOKIE) {\r\n            this.randomAI();\r\n          } else if (this.state.p1Mode === MODE_EASY) {\r\n            this.minimaxAI(MINIMAX_DEPTH_1);\r\n          } else if (this.state.p1Mode === MODE_NORMAL) {\r\n            this.qLearningAI();\r\n          } else if (this.state.p1Mode === MODE_HARD) {\r\n            this.minimaxAI(MINIMAX_DEPTH_2);\r\n          } else if (this.state.p1Mode === MODE_EXPERT) {\r\n            this.minimaxAI(MINIMAX_DEPTH_4);\r\n          } else if (this.state.p1Mode === MODE_EXTREME) {\r\n            this.minimaxAI(MINIMAX_DEPTH_6);\r\n          }\r\n        } else if (\r\n          this.state.turn === PLAYER_2 &&\r\n          this.state.p2Mode !== MODE_PLAYER\r\n        ) {\r\n          // Run AI for player 2\r\n          if (this.state.p2Mode === MODE_ROOKIE) {\r\n            this.randomAI();\r\n          } else if (this.state.p2Mode === MODE_EASY) {\r\n            this.minimaxAI(MINIMAX_DEPTH_1);\r\n          } else if (this.state.p2Mode === MODE_NORMAL) {\r\n            this.qLearningAI();\r\n          } else if (this.state.p2Mode === MODE_HARD) {\r\n            this.minimaxAI(MINIMAX_DEPTH_2);\r\n          } else if (this.state.p2Mode === MODE_EXPERT) {\r\n            this.minimaxAI(MINIMAX_DEPTH_4);\r\n          } else if (this.state.p2Mode === MODE_EXTREME) {\r\n            this.minimaxAI(MINIMAX_DEPTH_6);\r\n          }\r\n        }\r\n      },\r\n      SIMULATE ? 0 : (1000 * MAX_AI_SPEED_SECONDS) / this.state.aiSpeed\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Steps the game using a random AI.\r\n   */\r\n  randomAI() {\r\n    const validActions = this.game.getValidActions();\r\n    const action =\r\n      validActions[Math.floor(Math.random() * validActions.length)];\r\n\r\n    this.step(action);\r\n  }\r\n\r\n  /**\r\n   * Steps the game using a minimax AI.\r\n   * @param {number} depth The minimax depth\r\n   */\r\n  minimaxAI(depth) {\r\n    let maxVal = Number.NEGATIVE_INFINITY;\r\n    let maxCols = [];\r\n\r\n    for (const col of this.game.getValidActions()) {\r\n      const board = getNextBoard(this.state.board, col, this.state.turn);\r\n\r\n      const val = minimax(\r\n        board,\r\n        depth - 1,\r\n        Number.NEGATIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n        false,\r\n        this.state.turn\r\n      );\r\n\r\n      if (val > maxVal) {\r\n        // New max, reset maxCols\r\n        maxVal = val;\r\n        maxCols = [col];\r\n      } else if (val === maxVal) {\r\n        // Same max, add to array of possible choices\r\n        maxCols.push(col);\r\n      }\r\n    }\r\n\r\n    // Random action from max cols\r\n    const action = maxCols[Math.floor(Math.random() * maxCols.length)];\r\n\r\n    this.step(action);\r\n  }\r\n\r\n  /**\r\n   * Steps the game using a Q-learning AI.\r\n   */\r\n  qLearningAI() {\r\n    // Clean memory\r\n    tf.tidy(() => {\r\n      // Get correct state representation\r\n      const state =\r\n        this.state.turn === PLAYER_1\r\n          ? this.game.getState()\r\n          : this.game.getInvertedState();\r\n      const stateTensor = getStateTensor(state);\r\n\r\n      // Get q-values for each action as an array\r\n      const qs = Array.from(this.model.predict(stateTensor).dataSync());\r\n\r\n      // Mask valid actions\r\n      const validActions = this.game.getValidActions();\r\n      const qActions = [];\r\n\r\n      // Save q-action pairs\r\n      qs.forEach((q, action) => {\r\n        if (validActions.includes(action)) {\r\n          qActions.push({ q, action });\r\n        }\r\n      });\r\n\r\n      // Get action by max q-value\r\n      let maxQ = -Infinity;\r\n      let action = -1;\r\n\r\n      qActions.forEach((qAction) => {\r\n        if (qAction.q > maxQ) {\r\n          maxQ = qAction.q;\r\n          action = qAction.action;\r\n        }\r\n      });\r\n\r\n      this.step(action);\r\n    });\r\n  }\r\n\r\n  render() {\r\n    let turnOrWinnerText;\r\n\r\n    if (this.state.winner !== GAME_IN_PROGRESS) {\r\n      if (this.state.winner === DRAW) {\r\n        turnOrWinnerText = \"Draw\";\r\n      } else {\r\n        turnOrWinnerText = `Player ${\r\n          this.state.winner === PLAYER_1 ? \"1\" : \"2\"\r\n        } wins`;\r\n      }\r\n    } else {\r\n      turnOrWinnerText = `Player ${\r\n        this.state.turn === PLAYER_1 ? \"1\" : \"2\"\r\n      } turn`;\r\n    }\r\n\r\n    return (\r\n      <div className=\"App container-fluid text-center pt-5\">\r\n        <div className=\"row\">\r\n          <div className=\"col\">\r\n            <h1 className=\"font-weight-bold\">Connect 4 AI</h1>\r\n            <h5>Play versus Player/AI or watch AI play against AI.</h5>\r\n            <div className=\"row justify-content-center\">\r\n              <div className=\"col col-auto pt-3\">\r\n                <h4>Player 1</h4>\r\n                <select\r\n                  onChange={(e) => this.handleOnChangePlayer(e, PLAYER_1)}\r\n                >\r\n                  {OPTIONS.map((option) => {\r\n                    return <option key={`p1-${option}`}>{option}</option>;\r\n                  })}\r\n                </select>\r\n              </div>\r\n              <div className=\"col col-auto pt-3\">\r\n                <h4>Player 2</h4>\r\n                <select\r\n                  onChange={(e) => this.handleOnChangePlayer(e, PLAYER_2)}\r\n                >\r\n                  {OPTIONS.map((option) => {\r\n                    return <option key={`p2-${option}`}>{option}</option>;\r\n                  })}\r\n                </select>\r\n              </div>\r\n            </div>\r\n            <div className=\"row justify-content-center pt-3\">\r\n              <div className=\"col col-10 col-sm-8 col-md-6 col-lg-4 col-xl-2\">\r\n                <input\r\n                  type=\"range\"\r\n                  min={0.01}\r\n                  max={1}\r\n                  step={0.01}\r\n                  defaultValue={this.state.aiSpeed}\r\n                  onChange={this.handleOnChangeAISpeed}\r\n                />\r\n              </div>\r\n            </div>\r\n            <h5>AI speed: {this.state.aiSpeed}</h5>\r\n            <div className=\"mt-3\">\r\n              <Button value=\"New Game\" onClick={this.handleOnClickNewGame} />\r\n            </div>\r\n            <h4 className=\"mt-5\">{turnOrWinnerText}</h4>\r\n            <div className=\"row justify-content-center pt-3\">\r\n              <div className=\"col col-auto\">\r\n                <Board\r\n                  ROWS={ROWS}\r\n                  COLS={COLS}\r\n                  onClick={this.handleOnClickBoard}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <GithubCorner\r\n          href=\"https://github.com/ryantran2165/connect4-ai\"\r\n          bannerColor=\"#222\"\r\n          octoColor=\"#7fffd4\"\r\n          target=\"_blank\"\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport \"./index.scss\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}